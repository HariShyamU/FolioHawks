<!DOCTYPE html>
<html lang="en" dir="ltr">
  <head>
    <meta charset="utf-8">
    <title></title>
  </head>
  <body style="margin:0;">
    <style media="screen">
      body {
        height: 100vh;
        width: 100%;
        overflow: hidden;
      }
    </style>


    <script src="three.min.js"> </script>
  </body>
  <script type="text/javascript">
  var scene = new THREE.Scene();

  /**
  * Camera
  **/

  // Specify the portion of the scene visiable at any time (in degrees)
  var fieldOfView = 75;

  // Specify the camera's aspect ratio
  var aspectRatio = window.innerWidth / window.innerHeight;

  // Specify the near and far clipping planes. Only objects
  // between those planes will be rendered in the scene
  // (these values help control the number of items rendered
  // at any given time)
  var nearPlane = 0.1;
  var farPlane = 1000;

  // Use the values specified above to create a camera
  var camera = new THREE.PerspectiveCamera(
    fieldOfView, aspectRatio, nearPlane, farPlane
  );

  // Finally, set the camera's position in the z-dimension
  camera.position.z = 5;

  /**
  * Renderer
  **/

  // Create the canvas with a renderer
  var renderer = new THREE.WebGLRenderer({antialias: true});

  // Specify the size of the canvas
  renderer.setSize( window.innerWidth, window.innerHeight );

  // Add the canvas to the DOM
  document.body.appendChild( renderer.domElement );

  /**
  * Image
  **/

  // Create a texture loader so we can load our image file
  var loader = new THREE.TextureLoader();

  // Load an image file into a custom material
  var material = new THREE.MeshLambertMaterial({
    // map: loader.load('eye.png')
    color: 0xff0000,
    wireframe:true
  });

  // create a plane geometry for the image with a width of 10
  // and a height that preserves the image's aspect ratio
  var geometry = new THREE.SphereGeometry(1, 16, 16);

  // combine our image geometry and material into a mesh
  var mesh = new THREE.Mesh(geometry, material);

  // set the position of the image mesh in the x,y,z dimensions
  mesh.position.set(0,0,0)

  // add the image to the scene
  scene.add(mesh);

  /**
  * Lights
  **/

  // Add a point light with #fff color, .7 intensity, and 0 distance
  var light = new THREE.PointLight( 0xffffff, 0.7, 0 );

  // Specify the light's position
  light.position.set(100, 100, 100 );

  // Add the light to the scene
  scene.add(light)

  // window.addEventListener("mousemove", onmousemove, false);
  //
  // var plane = new THREE.Plane(new THREE.Vector3(0, 0, 1), 0);
  // var raycaster = new THREE.Raycaster();
  // var mouse = new THREE.Vector2();
  // var intersectPoint = new THREE.Vector3();

  function onmousemove(event) {
    // raycaster.setFromCamera(mouse, camera);
    // raycaster.ray.intersectPlane(plane, intersectPoint);
    // mesh.lookAt(intersectPoint);
  }

  /**
  * Render!
  **/

  // The main animation function that re-renders the scene each animation frame
  render();

  function render() {
    mesh.rotation.y+=0.01;
    requestAnimationFrame(render);
    renderer.render(scene, camera);
  }
  </script>
</html>
